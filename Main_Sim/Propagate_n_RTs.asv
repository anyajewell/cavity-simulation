function [Gau, loss_frac, centerx, centery] = Propagate_n_RTs(consts, sim, laser, frame, mirror, outputs, toggles)

    for a = 1:RTs
        Gau_a = laser.Gau; % beam profile at the start of this round trip

        % L --> R
        for i = 1:Nz
            pos = z(i); % current position
            Omega = frame.Omega; % opportunity to read/update Omega from other code
            accel = frame.accel; % opportunity to read/update accel from other code
            if pos + sim.dz > sim.L/2 
                dz1 = sim.Zmax-pos; 
                if dz1 == 0 % beam already at mirror
                    if toggles.track_centers == true
                        outputs.centerx(end+1) = trapz(trapz(X.*abs(Gau).^2))/trapz(trapz(abs(Gau).^2)); % track center x
                        outputs.centery(end+1) = trapz(trapz(Y.*abs(Gau).^2))/trapz(trapz(abs(Gau).^2)); % track center y
                    end
                    break
                else % propagate by fractional step to L
                [laser, outputs] = Prop(consts, sim, laser, frame, mirror, outputs, toggles); % propagate fractional step to mirror
                end
            else % propagate by dz, as normal
                [laser, outputs] = Prop(consts, sim, laser, frame, mirror, outputs, toggles); % propagation loop
            end
        end
    
        % Interact with mirror (RHS)
        theta_x1 = 0; theta_y1 = 0; % query mirror misalignment
        phi_tilt1 = 2*k0*(theta_x1*X + theta_y1*Y);
        tmask1 = exp(1i*phi_tilt1); % tilt mask
        Gau = Gau.*cmask1.*rmask1.*tmask1; % clip and shape the beam
        [Zmax, dz, z] = Turn_Around(Zmax, dz, Nz);

        imagesc(x,y,abs(Gau)); axis([-0.5 0.5 -0.5 0.5]); axis square; xlabel('x [m]'); ylabel('y [m]'); hold on; 
        if toggles.track_centers == true
            plot(outputs.centerx(end),outputs.centery(end),'ro'); hold off;
        end
        
        f = getframe(gcf); display(z(i));
        writeVideo(v,f);
    
        % R --> L
        for i = 1:Nz
            pos = z(i); % current position
            frame.Omega = Omega; % opportunity to read/update Omega from other code
            frame.accel = accel; % opportunity to read/update accel from other code
            if pos + sim.dz < -sim.L/2 
                dz1 = sim.Zmax-pos; 
                if dz1 == 0 % beam already at mirror
                    if track_centers == true
                        outputs.centerx(end+1) = trapz(trapz(X.*abs(Gau).^2))/trapz(trapz(abs(Gau).^2)); % track center x
                        outputs.centery(end+1) = trapz(trapz(Y.*abs(Gau).^2))/trapz(trapz(abs(Gau).^2)); % track center y
                    end
                    break
                else % propagate by fractional step to L
                [laser, outputs] = Prop(consts, sim, laser, frame, mirror, outputs, toggles); % propagate fractional step to mirror
                end
            else % propagate by dz, as normal
                [laser, outputs] = Prop(consts, sim, laser, frame, mirror, outputs, toggles); % propagation loop
            end
        end
    
        % Interact with mirror (LHS)
        theta_x2 = 0; theta_y2 = 0; % query mirror misalignment
        if a == 30
            theta_x2 = 0.5e-6; theta_y2 = 0.5e-6;
        end
        phi_tilt2 = 2*k0*(theta_x2*X + theta_y2*Y);
        tmask2 = exp(1i*phi_tilt2); % tilt mask
        laser.Gau = Gau.*cmask2.*rmask2.*tmask2; % clip and shape the beam
        [Zmax, dz, z] = Turn_Around(Zmax, dz, Nz);

        % Visualization
        imagesc(x,y,abs(Gau)); axis([-0.5 0.5 -0.5 0.5]); axis square; xlabel('x [m]'); ylabel('y [m]');  
        set(gcf, 'Color', 'w'); set(gca, 'Color', 'w'); hold on;
        if track_centers == true
            plot(centerx(end),centery(end),'ro'); hold off;
        end
        f = getframe(gcf); display(z(i));
        writeVideo(v,f);
    
        % Calculate and store loss
        loss_a =  1 - sum(abs(Gau).^2,'all') / sum(abs(Gau_a).^2,'all'); % loss this time
        outputs.loss_frac(a) = loss_a;
    end

    if toggles.track_centers == true % fix counting
        outputs.centerx(end) = [];
        centery(end) = [];
    end

end